// @flow

import { Component, createElement } from 'react'
import PropTypes from 'prop-types'

import type { Theme } from './ThemeProvider'
import createWarnTooManyClasses from '../utils/createWarnTooManyClasses'

import validAttr from '../utils/validAttr'
import isTag from '../utils/isTag'
import isStyledComponent from '../utils/isStyledComponent'
import getComponentName from '../utils/getComponentName'
<<<<<<< HEAD
import determineTheme from '../utils/determineTheme'
import escape from '../utils/escape'
=======
>>>>>>> 3e7cc9eba236ff5c5205c34bae31be88b995768b
import type { RuleSet, Target } from '../types'

import { CHANNEL, CHANNEL_NEXT, CONTEXT_CHANNEL_SHAPE } from './ThemeProvider'
import StyleSheet, { CONTEXT_KEY } from './StyleSheet'
<<<<<<< HEAD
import ServerStyleSheet from './ServerStyleSheet'
=======

const escapeRegex = /[[\].#*$><+~=|^:(),"'`]/g
const multiDashRegex = /--+/g
>>>>>>> 3e7cc9eba236ff5c5205c34bae31be88b995768b

// HACK for generating all static styles without needing to allocate
// an empty execution context every single time...
const STATIC_EXECUTION_CONTEXT = {}

export default (ComponentStyle: Function, constructWithOptions: Function) => {
<<<<<<< HEAD
  const identifiers = {}

  /* We depend on components having unique IDs */
  const generateId = (_displayName: string, parentComponentId: string) => {
    const displayName =
      typeof _displayName !== 'string' ? 'sc' : escape(_displayName)

    let componentId

    /**
     * only fall back to hashing the component injection order if
     * a proper displayName isn't provided by the babel plugin
     */
    if (!_displayName) {
      const nr = (identifiers[displayName] || 0) + 1
      identifiers[displayName] = nr

      componentId = `${displayName}-${ComponentStyle.generateName(
        displayName + nr,
      )}`
    } else {
      componentId = `${displayName}-${ComponentStyle.generateName(displayName)}`
    }

=======
  /* We depend on components having unique IDs */
  const identifiers = {}
  const generateId = (_displayName: string, parentComponentId: string) => {
    const displayName = typeof _displayName !== 'string' ?
      'sc' : _displayName
        .replace(escapeRegex, '-') // Replace all possible CSS selectors
        .replace(multiDashRegex, '-') // Replace multiple -- with single -

    const nr = (identifiers[displayName] || 0) + 1
    identifiers[displayName] = nr

    const hash = ComponentStyle.generateName(displayName + nr)
    const componentId = `${displayName}-${hash}`
>>>>>>> 3e7cc9eba236ff5c5205c34bae31be88b995768b
    return parentComponentId !== undefined
      ? `${parentComponentId}-${componentId}`
      : componentId
  }

  class BaseStyledComponent extends Component {
    static target: Target
    static styledComponentId: string
    static attrs: Object
    static componentStyle: Object
    static warnTooManyClasses: Function

    attrs = {}
    state = {
      theme: null,
      generatedClassName: '',
    }
    unsubscribeId: number = -1

    unsubscribeFromContext() {
      if (this.unsubscribeId !== -1) {
        this.context[CHANNEL_NEXT].unsubscribe(this.unsubscribeId)
      }
    }

    buildExecutionContext(theme: any, props: any) {
      const { attrs } = this.constructor
      const context = { ...props, theme }
      if (attrs === undefined) {
        return context
      }

      this.attrs = Object.keys(attrs).reduce((acc, key) => {
        const attr = attrs[key]
        // eslint-disable-next-line no-param-reassign
        acc[key] = typeof attr === 'function' ? attr(context) : attr
        return acc
      }, {})

      return { ...context, ...this.attrs }
    }

    generateAndInjectStyles(theme: any, props: any) {
      const { attrs, componentStyle, warnTooManyClasses } = this.constructor
      const styleSheet = this.context[CONTEXT_KEY] || StyleSheet.instance

      // staticaly styled-components don't need to build an execution context object,
      // and shouldn't be increasing the number of class names
      if (componentStyle.isStatic && attrs === undefined) {
<<<<<<< HEAD
        return componentStyle.generateAndInjectStyles(
          STATIC_EXECUTION_CONTEXT,
          styleSheet,
        )
      } else {
        const executionContext = this.buildExecutionContext(theme, props)
        const className = componentStyle.generateAndInjectStyles(
          executionContext,
          styleSheet,
        )

        if (
          process.env.NODE_ENV !== 'production' &&
          warnTooManyClasses !== undefined
        ) {
          warnTooManyClasses(className)
        }
=======
        return componentStyle.generateAndInjectStyles(STATIC_EXECUTION_CONTEXT, styleSheet)
      } else {
        const executionContext = this.buildExecutionContext(theme, props)
        const className = componentStyle.generateAndInjectStyles(executionContext, styleSheet)

        if (warnTooManyClasses !== undefined) warnTooManyClasses(className)
>>>>>>> 3e7cc9eba236ff5c5205c34bae31be88b995768b

        return className
      }
    }

    componentWillMount() {
      const { componentStyle } = this.constructor
      const styledContext = this.context[CHANNEL_NEXT]

      // If this is a staticaly-styled component, we don't need to the theme
      // to generate or build styles.
      if (componentStyle.isStatic) {
        const generatedClassName = this.generateAndInjectStyles(
          STATIC_EXECUTION_CONTEXT,
          this.props,
        )
        this.setState({ generatedClassName })
<<<<<<< HEAD
        // If there is a theme in the context, subscribe to the event emitter. This
        // is necessary due to pure components blocking context updates, this circumvents
        // that by updating when an event is emitted
=======
      // If there is a theme in the context, subscribe to the event emitter. This
      // is necessary due to pure components blocking context updates, this circumvents
      // that by updating when an event is emitted
>>>>>>> 3e7cc9eba236ff5c5205c34bae31be88b995768b
      } else if (styledContext !== undefined) {
        const { subscribe } = styledContext
        this.unsubscribeId = subscribe(nextTheme => {
          // This will be called once immediately
<<<<<<< HEAD
          const theme = determineTheme(
            this.props,
            nextTheme,
            this.constructor.defaultProps,
          )
          const generatedClassName = this.generateAndInjectStyles(
            theme,
            this.props,
          )

=======

          // Props should take precedence over ThemeProvider, which should take precedence over
          // defaultProps, but React automatically puts defaultProps on props.
          const { defaultProps } = this.constructor
          /* eslint-disable react/prop-types */
          const isDefaultTheme = defaultProps && this.props.theme === defaultProps.theme
          const theme = this.props.theme && !isDefaultTheme ? this.props.theme : nextTheme
          /* eslint-enable */
          const generatedClassName = this.generateAndInjectStyles(theme, this.props)
>>>>>>> 3e7cc9eba236ff5c5205c34bae31be88b995768b
          this.setState({ theme, generatedClassName })
        })
      } else {
        // eslint-disable-next-line react/prop-types
        const theme = this.props.theme || {}
        const generatedClassName = this.generateAndInjectStyles(
          theme,
          this.props,
        )
        this.setState({ theme, generatedClassName })
      }
    }

<<<<<<< HEAD
    componentWillReceiveProps(nextProps: {
      theme?: Theme,
      [key: string]: any,
    }) {
=======
    componentWillReceiveProps(nextProps: { theme?: Theme, [key: string]: any }) {
>>>>>>> 3e7cc9eba236ff5c5205c34bae31be88b995768b
      // If this is a staticaly-styled component, we don't need to listen to
      // props changes to update styles
      const { componentStyle } = this.constructor
      if (componentStyle.isStatic) {
        return
      }

<<<<<<< HEAD
      this.setState(oldState => {
        const theme = determineTheme(
          nextProps,
          oldState.theme,
          this.constructor.defaultProps,
        )
        const generatedClassName = this.generateAndInjectStyles(
          theme,
          nextProps,
        )
=======
      this.setState((oldState) => {
        // Props should take precedence over ThemeProvider, which should take precedence over
        // defaultProps, but React automatically puts defaultProps on props.
        const { defaultProps } = this.constructor
        /* eslint-disable react/prop-types */
        const isDefaultTheme = defaultProps && nextProps.theme === defaultProps.theme
        const theme = nextProps.theme && !isDefaultTheme ? nextProps.theme : oldState.theme
        /* eslint-enable */
        const generatedClassName = this.generateAndInjectStyles(theme, nextProps)
>>>>>>> 3e7cc9eba236ff5c5205c34bae31be88b995768b

        return { theme, generatedClassName }
      })
    }

    componentWillUnmount() {
      this.unsubscribeFromContext()
    }

    render() {
      // eslint-disable-next-line react/prop-types
      const { innerRef } = this.props
      const { generatedClassName } = this.state
      const { styledComponentId, target } = this.constructor

      const isTargetTag = isTag(target)

      const className = [
        // eslint-disable-next-line react/prop-types
        this.props.className,
        styledComponentId,
        this.attrs.className,
        generatedClassName,
<<<<<<< HEAD
      ]
        .filter(Boolean)
        .join(' ')
=======
      ].filter(Boolean).join(' ')
>>>>>>> 3e7cc9eba236ff5c5205c34bae31be88b995768b

      const baseProps = {
        ...this.attrs,
        className,
      }

      if (isStyledComponent(target)) {
        baseProps.innerRef = innerRef
      } else {
        baseProps.ref = innerRef
      }

<<<<<<< HEAD
      const propsForElement = Object.keys(this.props).reduce(
        (acc, propName) => {
=======
      const propsForElement = Object
        .keys(this.props)
        .reduce((acc, propName) => {
>>>>>>> 3e7cc9eba236ff5c5205c34bae31be88b995768b
          // Don't pass through non HTML tags through to HTML elements
          // always omit innerRef
          if (
            propName !== 'innerRef' &&
            propName !== 'className' &&
            (!isTargetTag || validAttr(propName))
          ) {
            // eslint-disable-next-line no-param-reassign
            acc[propName] = this.props[propName]
          }

          return acc
<<<<<<< HEAD
        },
        baseProps,
      )
=======
        }, baseProps)
>>>>>>> 3e7cc9eba236ff5c5205c34bae31be88b995768b

      return createElement(target, propsForElement)
    }
  }

  const createStyledComponent = (
    target: Target,
    options: Object,
    rules: RuleSet,
  ) => {
    const {
<<<<<<< HEAD
      displayName = isTag(target)
        ? `styled.${target}`
        : `Styled(${getComponentName(target)})`,
=======
      displayName = isTag(target) ? `styled.${target}` : `Styled(${getComponentName(target)})`,
>>>>>>> 3e7cc9eba236ff5c5205c34bae31be88b995768b
      componentId = generateId(options.displayName, options.parentComponentId),
      ParentComponent = BaseStyledComponent,
      rules: extendingRules,
      attrs,
    } = options

<<<<<<< HEAD
    const styledComponentId =
      options.displayName && options.componentId
        ? `${escape(options.displayName)}-${options.componentId}`
        : componentId

    const componentStyle = new ComponentStyle(
      extendingRules === undefined ? rules : extendingRules.concat(rules),
      attrs,
=======
    const styledComponentId = (options.displayName && options.componentId) ?
      `${options.displayName}-${options.componentId}` : componentId

    let warnTooManyClasses
    if (process.env.NODE_ENV !== 'production') {
      warnTooManyClasses = createWarnTooManyClasses(displayName)
    }

    const componentStyle = new ComponentStyle(
      extendingRules === undefined ? rules : extendingRules.concat(rules),
>>>>>>> 3e7cc9eba236ff5c5205c34bae31be88b995768b
      styledComponentId,
    )

    class StyledComponent extends ParentComponent {
      static contextTypes = {
        [CHANNEL]: PropTypes.func,
        [CHANNEL_NEXT]: CONTEXT_CHANNEL_SHAPE,
<<<<<<< HEAD
        [CONTEXT_KEY]: PropTypes.oneOfType([
          PropTypes.instanceOf(StyleSheet),
          PropTypes.instanceOf(ServerStyleSheet),
        ]),
=======
        [CONTEXT_KEY]: PropTypes.instanceOf(StyleSheet),
>>>>>>> 3e7cc9eba236ff5c5205c34bae31be88b995768b
      }

      static displayName = displayName
      static styledComponentId = styledComponentId
      static attrs = attrs
      static componentStyle = componentStyle
<<<<<<< HEAD
=======
      static warnTooManyClasses = warnTooManyClasses
>>>>>>> 3e7cc9eba236ff5c5205c34bae31be88b995768b
      static target = target

      static withComponent(tag) {
        const { componentId: previousComponentId, ...optionsToCopy } = options

        const newComponentId =
          previousComponentId &&
<<<<<<< HEAD
          `${previousComponentId}-${
            isTag(tag) ? tag : escape(getComponentName(tag))
          }`
=======
          `${previousComponentId}-${isTag(tag) ? tag : getComponentName(tag)}`
>>>>>>> 3e7cc9eba236ff5c5205c34bae31be88b995768b

        const newOptions = {
          ...optionsToCopy,
          componentId: newComponentId,
          ParentComponent: StyledComponent,
        }

        return createStyledComponent(tag, newOptions, rules)
      }

      static get extend() {
        const {
          rules: rulesFromOptions,
          componentId: parentComponentId,
          ...optionsToCopy
        } = options

        const newRules =
          rulesFromOptions === undefined
            ? rules
            : rulesFromOptions.concat(rules)

        const newOptions = {
          ...optionsToCopy,
          rules: newRules,
          parentComponentId,
          ParentComponent: StyledComponent,
        }

        return constructWithOptions(createStyledComponent, target, newOptions)
      }
    }

<<<<<<< HEAD
    if (process.env.NODE_ENV !== 'production') {
      StyledComponent.warnTooManyClasses = createWarnTooManyClasses(displayName)
    }

=======
>>>>>>> 3e7cc9eba236ff5c5205c34bae31be88b995768b
    return StyledComponent
  }

  return createStyledComponent
}
