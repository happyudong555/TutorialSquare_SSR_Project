<<<<<<< HEAD
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
=======
'use strict';
>>>>>>> 3e7cc9eba236ff5c5205c34bae31be88b995768b

Object.defineProperty(exports, "__esModule", {
  value: true
});
<<<<<<< HEAD
exports.default = onDemandEntryHandler;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _stringify = _interopRequireDefault(require("@babel/runtime/core-js/json/stringify"));

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _promise = _interopRequireDefault(require("@babel/runtime/core-js/promise"));

var _keys = _interopRequireDefault(require("@babel/runtime/core-js/object/keys"));

var _set = _interopRequireDefault(require("@babel/runtime/core-js/set"));

var _symbol = _interopRequireDefault(require("@babel/runtime/core-js/symbol"));

var _DynamicEntryPlugin = _interopRequireDefault(require("webpack/lib/DynamicEntryPlugin"));

var _events = require("events");

var _path = require("path");

var _url = require("url");

var _touch = _interopRequireDefault(require("touch"));

var _promisify = _interopRequireDefault(require("./lib/promisify"));

var _glob = _interopRequireDefault(require("glob"));

var _require = require("./require");

var _utils = require("./build/webpack/utils");

var _utils2 = require("./utils");

var ADDED = (0, _symbol.default)('added');
var BUILDING = (0, _symbol.default)('building');
var BUILT = (0, _symbol.default)('built');
var glob = (0, _promisify.default)(_glob.default);

function onDemandEntryHandler(devMiddleware, compilers, _ref) {
  var dir = _ref.dir,
      dev = _ref.dev,
      reload = _ref.reload,
      pageExtensions = _ref.pageExtensions,
      _ref$maxInactiveAge = _ref.maxInactiveAge,
      maxInactiveAge = _ref$maxInactiveAge === void 0 ? 1000 * 60 : _ref$maxInactiveAge,
      _ref$pagesBufferLengt = _ref.pagesBufferLength,
      pagesBufferLength = _ref$pagesBufferLengt === void 0 ? 2 : _ref$pagesBufferLengt;
=======

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _stringify = require('babel-runtime/core-js/json/stringify');

var _stringify2 = _interopRequireDefault(_stringify);

var _regenerator = require('babel-runtime/regenerator');

var _regenerator2 = _interopRequireDefault(_regenerator);

var _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _toConsumableArray2 = require('babel-runtime/helpers/toConsumableArray');

var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _keys = require('babel-runtime/core-js/object/keys');

var _keys2 = _interopRequireDefault(_keys);

var _symbol = require('babel-runtime/core-js/symbol');

var _symbol2 = _interopRequireDefault(_symbol);

exports.default = onDemandEntryHandler;

var _DynamicEntryPlugin = require('webpack/lib/DynamicEntryPlugin');

var _DynamicEntryPlugin2 = _interopRequireDefault(_DynamicEntryPlugin);

var _events = require('events');

var _path = require('path');

var _url = require('url');

var _resolve = require('./resolve');

var _resolve2 = _interopRequireDefault(_resolve);

var _touch = require('touch');

var _touch2 = _interopRequireDefault(_touch);

var _utils = require('./utils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var ADDED = (0, _symbol2.default)('added');
var BUILDING = (0, _symbol2.default)('building');
var BUILT = (0, _symbol2.default)('built');

function onDemandEntryHandler(devMiddleware, compiler, _ref) {
  var dir = _ref.dir,
      dev = _ref.dev,
      reload = _ref.reload,
      _ref$maxInactiveAge = _ref.maxInactiveAge,
      maxInactiveAge = _ref$maxInactiveAge === undefined ? 1000 * 25 : _ref$maxInactiveAge,
      _ref$pagesBufferLengt = _ref.pagesBufferLength,
      pagesBufferLength = _ref$pagesBufferLengt === undefined ? 2 : _ref$pagesBufferLengt;

>>>>>>> 3e7cc9eba236ff5c5205c34bae31be88b995768b
  var entries = {};
  var lastAccessPages = [''];
  var doneCallbacks = new _events.EventEmitter();
  var invalidator = new Invalidator(devMiddleware);
  var touchedAPage = false;
  var reloading = false;
  var stopped = false;
<<<<<<< HEAD
  var reloadCallbacks = new _events.EventEmitter(); // Keep the names of compilers which are building pages at a given moment.

  var currentBuilders = new _set.default();
  compilers.forEach(function (compiler) {
    compiler.plugin('make', function (compilation, done) {
      invalidator.startBuilding();
      currentBuilders.add(compiler.name);
      var allEntries = (0, _keys.default)(entries).map(function (page) {
        var _entries$page = entries[page],
            name = _entries$page.name,
            entry = _entries$page.entry;
        entries[page].status = BUILDING;
        return addEntry(compilation, compiler.context, name, entry);
      });

      _promise.default.all(allEntries).then(function () {
        return done();
      }).catch(done);
    });
    compiler.plugin('done', function (stats) {
      // Wait until all the compilers mark the build as done.
      currentBuilders.delete(compiler.name);
      if (currentBuilders.size !== 0) return;
      var compilation = stats.compilation;
      var hardFailedPages = compilation.errors.filter(function (e) {
        // Make sure to only pick errors which marked with missing modules
        var hasNoModuleFoundError = /ENOENT/.test(e.message) || /Module not found/.test(e.message);
        if (!hasNoModuleFoundError) return false; // The page itself is missing. So this is a failed page.

        if (_utils2.IS_BUNDLED_PAGE.test(e.module.name)) return true; // No dependencies means this is a top level page.
        // So this is a failed page.

        return e.module.dependencies.length === 0;
      }).map(function (e) {
        return e.module.chunks;
      }).reduce(function (a, b) {
        return (0, _toConsumableArray2.default)(a).concat((0, _toConsumableArray2.default)(b));
      }, []).map(function (c) {
        var pageName = _utils2.MATCH_ROUTE_NAME.exec(c.name)[1];

        return normalizePage("/".concat(pageName));
      }); // Call all the doneCallbacks

      (0, _keys.default)(entries).forEach(function (page) {
        var entryInfo = entries[page];
        if (entryInfo.status !== BUILDING) return; // With this, we are triggering a filesystem based watch trigger
        // It'll memorize some timestamp related info related to common files used
        // in the page
        // That'll reduce the page building time significantly.

        if (!touchedAPage) {
          setTimeout(function () {
            _touch.default.sync(entryInfo.pathname);
          }, 1000);
          touchedAPage = true;
        }

        entryInfo.status = BUILT;
        entries[page].lastActiveTime = Date.now();
        doneCallbacks.emit(page);
      });
      invalidator.doneBuilding(compiler.name);

      if (hardFailedPages.length > 0 && !reloading) {
        console.log("> Reloading webpack due to inconsistant state of pages(s): ".concat(hardFailedPages.join(', ')));
        reloading = true;
        reload().then(function () {
          console.log('> Webpack reloaded.');
          reloadCallbacks.emit('done');
          stop();
        }).catch(function (err) {
          console.error("> Webpack reloading failed: ".concat(err.message));
          console.error(err.stack);
          process.exit(1);
        });
      }
    });
  });
=======
  var reloadCallbacks = new _events.EventEmitter();

  compiler.plugin('make', function (compilation, done) {
    var _this = this;

    invalidator.startBuilding();

    var allEntries = (0, _keys2.default)(entries).map(function (page) {
      var _entries$page = entries[page],
          name = _entries$page.name,
          entry = _entries$page.entry;

      entries[page].status = BUILDING;
      return addEntry(compilation, _this.context, name, entry);
    });

    _promise2.default.all(allEntries).then(function () {
      return done();
    }).catch(done);
  });

  compiler.plugin('done', function (stats) {
    var compilation = stats.compilation;

    var hardFailedPages = compilation.errors.filter(function (e) {
      // Make sure to only pick errors which marked with missing modules
      var hasNoModuleFoundError = /ENOENT/.test(e.message) || /Module not found/.test(e.message);
      if (!hasNoModuleFoundError) return false;

      // The page itself is missing. So this is a failed page.
      if (_utils.IS_BUNDLED_PAGE.test(e.module.name)) return true;

      // No dependencies means this is a top level page.
      // So this is a failed page.
      return e.module.dependencies.length === 0;
    }).map(function (e) {
      return e.module.chunks;
    }).reduce(function (a, b) {
      return [].concat((0, _toConsumableArray3.default)(a), (0, _toConsumableArray3.default)(b));
    }, []).map(function (c) {
      var pageName = _utils.MATCH_ROUTE_NAME.exec(c.name)[1];
      return normalizePage('/' + pageName);
    });

    // Call all the doneCallbacks
    (0, _keys2.default)(entries).forEach(function (page) {
      var entryInfo = entries[page];
      if (entryInfo.status !== BUILDING) return;

      // With this, we are triggering a filesystem based watch trigger
      // It'll memorize some timestamp related info related to common files used
      // in the page
      // That'll reduce the page building time significantly.
      if (!touchedAPage) {
        setTimeout(function () {
          _touch2.default.sync(entryInfo.pathname);
        }, 1000);
        touchedAPage = true;
      }

      entryInfo.status = BUILT;
      entries[page].lastActiveTime = Date.now();
      doneCallbacks.emit(page);
    });

    invalidator.doneBuilding();

    if (hardFailedPages.length > 0 && !reloading) {
      console.log('> Reloading webpack due to inconsistant state of pages(s): ' + hardFailedPages.join(', '));
      reloading = true;
      reload().then(function () {
        console.log('> Webpack reloaded.');
        reloadCallbacks.emit('done');
        stop();
      }).catch(function (err) {
        console.error('> Webpack reloading failed: ' + err.message);
        console.error(err.stack);
        process.exit(1);
      });
    }
  });

>>>>>>> 3e7cc9eba236ff5c5205c34bae31be88b995768b
  var disposeHandler = setInterval(function () {
    if (stopped) return;
    disposeInactiveEntries(devMiddleware, entries, lastAccessPages, maxInactiveAge);
  }, 5000);
<<<<<<< HEAD
  disposeHandler.unref();
=======
>>>>>>> 3e7cc9eba236ff5c5205c34bae31be88b995768b

  function stop() {
    clearInterval(disposeHandler);
    stopped = true;
    doneCallbacks = null;
    reloadCallbacks = null;
  }

  return {
    waitUntilReloaded: function waitUntilReloaded() {
<<<<<<< HEAD
      if (!reloading) return _promise.default.resolve(true);
      return new _promise.default(function (resolve) {
=======
      if (!reloading) return _promise2.default.resolve(true);
      return new _promise2.default(function (resolve) {
>>>>>>> 3e7cc9eba236ff5c5205c34bae31be88b995768b
        reloadCallbacks.once('done', function () {
          resolve();
        });
      });
    },
    ensurePage: function () {
<<<<<<< HEAD
      var _ensurePage = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee(page) {
        var normalizedPagePath, extensions, paths, relativePathToPage, pathname, _createEntry, name, files;

        return _regenerator.default.wrap(function _callee$(_context) {
=======
      var _ref2 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee(page) {
        var pagePath, pathname, name, entry;
        return _regenerator2.default.wrap(function _callee$(_context) {
>>>>>>> 3e7cc9eba236ff5c5205c34bae31be88b995768b
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return this.waitUntilReloaded();

              case 2:
                page = normalizePage(page);
<<<<<<< HEAD
                _context.prev = 3;
                normalizedPagePath = (0, _require.normalizePagePath)(page);
                _context.next = 11;
                break;

              case 7:
                _context.prev = 7;
                _context.t0 = _context["catch"](3);
                console.error(_context.t0);
                throw (0, _require.pageNotFoundError)(normalizedPagePath);

              case 11:
                extensions = pageExtensions.join('|');
                _context.next = 14;
                return glob("pages/{".concat(normalizedPagePath, "/index,").concat(normalizedPagePath, "}.+(").concat(extensions, ")"), {
                  cwd: dir
                });

              case 14:
                paths = _context.sent;

                if (!(paths.length === 0)) {
                  _context.next = 17;
                  break;
                }

                throw (0, _require.pageNotFoundError)(normalizedPagePath);

              case 17:
                relativePathToPage = paths[0];
                pathname = (0, _path.join)(dir, relativePathToPage);
                _createEntry = (0, _utils.createEntry)(relativePathToPage, {
                  pageExtensions: extensions
                }), name = _createEntry.name, files = _createEntry.files;
                _context.next = 22;
                return new _promise.default(function (resolve, reject) {
=======

                pagePath = (0, _path.join)(dir, 'pages', page);
                _context.next = 6;
                return (0, _resolve2.default)(pagePath);

              case 6:
                pathname = _context.sent;
                name = (0, _path.join)('bundles', pathname.substring(dir.length));
                entry = [pathname + '?entry'];
                _context.next = 11;
                return new _promise2.default(function (resolve, reject) {
>>>>>>> 3e7cc9eba236ff5c5205c34bae31be88b995768b
                  var entryInfo = entries[page];

                  if (entryInfo) {
                    if (entryInfo.status === BUILT) {
                      resolve();
                      return;
                    }

                    if (entryInfo.status === BUILDING) {
<<<<<<< HEAD
                      doneCallbacks.once(page, handleCallback);
=======
                      doneCallbacks.on(page, processCallback);
>>>>>>> 3e7cc9eba236ff5c5205c34bae31be88b995768b
                      return;
                    }
                  }

<<<<<<< HEAD
                  console.log("> Building page: ".concat(page));
                  entries[page] = {
                    name: name,
                    entry: files,
                    pathname: pathname,
                    status: ADDED
                  };
                  doneCallbacks.once(page, handleCallback);
                  invalidator.invalidate();

                  function handleCallback(err) {
=======
                  console.log('> Building page: ' + page);

                  entries[page] = { name: name, entry: entry, pathname: pathname, status: ADDED };
                  doneCallbacks.on(page, processCallback);

                  invalidator.invalidate();

                  function processCallback(err) {
>>>>>>> 3e7cc9eba236ff5c5205c34bae31be88b995768b
                    if (err) return reject(err);
                    resolve();
                  }
                });

<<<<<<< HEAD
              case 22:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this, [[3, 7]]);
      }));

      return function ensurePage(_x) {
        return _ensurePage.apply(this, arguments);
      };
    }(),
    middleware: function middleware() {
      var _this = this;
=======
              case 11:
              case 'end':
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function ensurePage(_x) {
        return _ref2.apply(this, arguments);
      }

      return ensurePage;
    }(),
    middleware: function middleware() {
      var _this2 = this;
>>>>>>> 3e7cc9eba236ff5c5205c34bae31be88b995768b

      return function (req, res, next) {
        if (stopped) {
          // If this handler is stopped, we need to reload the user's browser.
          // So the user could connect to the actually running handler.
          res.statusCode = 302;
          res.setHeader('Location', req.url);
          res.end('302');
        } else if (reloading) {
          // Webpack config is reloading. So, we need to wait until it's done and
          // reload user's browser.
          // So the user could connect to the new handler and webpack setup.
<<<<<<< HEAD
          _this.waitUntilReloaded().then(function () {
=======
          _this2.waitUntilReloaded().then(function () {
>>>>>>> 3e7cc9eba236ff5c5205c34bae31be88b995768b
            res.statusCode = 302;
            res.setHeader('Location', req.url);
            res.end('302');
          });
        } else {
          if (!/^\/_next\/on-demand-entries-ping/.test(req.url)) return next();

          var _parse = (0, _url.parse)(req.url, true),
              query = _parse.query;

          var page = normalizePage(query.page);
<<<<<<< HEAD
          var entryInfo = entries[page]; // If there's no entry.
          // Then it seems like an weird issue.

          if (!entryInfo) {
            var message = "Client pings, but there's no entry for page: ".concat(page);
            console.error(message);
            sendJson(res, {
              invalid: true
            });
            return;
          }

          sendJson(res, {
            success: true
          }); // We don't need to maintain active state of anything other than BUILT entries

          if (entryInfo.status !== BUILT) return; // If there's an entryInfo

          if (!lastAccessPages.includes(page)) {
            lastAccessPages.unshift(page); // Maintain the buffer max length

            if (lastAccessPages.length > pagesBufferLength) lastAccessPages.pop();
          }

=======
          var entryInfo = entries[page];

          // If there's no entry.
          // Then it seems like an weird issue.
          if (!entryInfo) {
            var message = 'Client pings, but there\'s no entry for page: ' + page;
            console.error(message);
            sendJson(res, { invalid: true });
            return;
          }

          sendJson(res, { success: true });

          // We don't need to maintain active state of anything other than BUILT entries
          if (entryInfo.status !== BUILT) return;

          // If there's an entryInfo
          if (!lastAccessPages.includes(page)) {
            lastAccessPages.unshift(page);

            // Maintain the buffer max length
            if (lastAccessPages.length > pagesBufferLength) lastAccessPages.pop();
          }
>>>>>>> 3e7cc9eba236ff5c5205c34bae31be88b995768b
          entryInfo.lastActiveTime = Date.now();
        }
      };
    }
  };
<<<<<<< HEAD
} // Based on https://github.com/webpack/webpack/blob/master/lib/DynamicEntryPlugin.js#L29-L37


function addEntry(compilation, context, name, entry) {
  return new _promise.default(function (resolve, reject) {
    var dep = _DynamicEntryPlugin.default.createDependency(entry, name);

=======
}

function addEntry(compilation, context, name, entry) {
  return new _promise2.default(function (resolve, reject) {
    var dep = _DynamicEntryPlugin2.default.createDependency(entry, name);
>>>>>>> 3e7cc9eba236ff5c5205c34bae31be88b995768b
    compilation.addEntry(context, dep, name, function (err) {
      if (err) return reject(err);
      resolve();
    });
  });
}

function disposeInactiveEntries(devMiddleware, entries, lastAccessPages, maxInactiveAge) {
  var disposingPages = [];
<<<<<<< HEAD
  (0, _keys.default)(entries).forEach(function (page) {
    var _entries$page2 = entries[page],
        lastActiveTime = _entries$page2.lastActiveTime,
        status = _entries$page2.status; // This means this entry is currently building or just added
    // We don't need to dispose those entries.

    if (status !== BUILT) return; // We should not build the last accessed page even we didn't get any pings
    // Sometimes, it's possible our XHR ping to wait before completing other requests.
    // In that case, we should not dispose the current viewing page

=======

  (0, _keys2.default)(entries).forEach(function (page) {
    var _entries$page2 = entries[page],
        lastActiveTime = _entries$page2.lastActiveTime,
        status = _entries$page2.status;

    // This means this entry is currently building or just added
    // We don't need to dispose those entries.

    if (status !== BUILT) return;

    // We should not build the last accessed page even we didn't get any pings
    // Sometimes, it's possible our XHR ping to wait before completing other requests.
    // In that case, we should not dispose the current viewing page
>>>>>>> 3e7cc9eba236ff5c5205c34bae31be88b995768b
    if (lastAccessPages.includes(page)) return;

    if (Date.now() - lastActiveTime > maxInactiveAge) {
      disposingPages.push(page);
    }
  });

  if (disposingPages.length > 0) {
    disposingPages.forEach(function (page) {
      delete entries[page];
    });
<<<<<<< HEAD
    console.log("> Disposing inactive page(s): ".concat(disposingPages.join(', ')));
    devMiddleware.invalidate();
  }
} // /index and / is the same. So, we need to identify both pages as the same.
// This also applies to sub pages as well.


=======
    console.log('> Disposing inactive page(s): ' + disposingPages.join(', '));
    devMiddleware.invalidate();
  }
}

// /index and / is the same. So, we need to identify both pages as the same.
// This also applies to sub pages as well.
>>>>>>> 3e7cc9eba236ff5c5205c34bae31be88b995768b
function normalizePage(page) {
  return page.replace(/\/index$/, '/');
}

function sendJson(res, payload) {
  res.setHeader('Content-Type', 'application/json');
  res.status = 200;
<<<<<<< HEAD
  res.end((0, _stringify.default)(payload));
} // Make sure only one invalidation happens at a time
// Otherwise, webpack hash gets changed and it'll force the client to reload.


var Invalidator =
/*#__PURE__*/
function () {
  function Invalidator(devMiddleware) {
    (0, _classCallCheck2.default)(this, Invalidator);
    this.devMiddleware = devMiddleware; // contains an array of types of compilers currently building

=======
  res.end((0, _stringify2.default)(payload));
}

// Make sure only one invalidation happens at a time
// Otherwise, webpack hash gets changed and it'll force the client to reload.

var Invalidator = function () {
  function Invalidator(devMiddleware) {
    (0, _classCallCheck3.default)(this, Invalidator);

    this.devMiddleware = devMiddleware;
>>>>>>> 3e7cc9eba236ff5c5205c34bae31be88b995768b
    this.building = false;
    this.rebuildAgain = false;
  }

<<<<<<< HEAD
  (0, _createClass2.default)(Invalidator, [{
    key: "invalidate",
=======
  (0, _createClass3.default)(Invalidator, [{
    key: 'invalidate',
>>>>>>> 3e7cc9eba236ff5c5205c34bae31be88b995768b
    value: function invalidate() {
      // If there's a current build is processing, we won't abort it by invalidating.
      // (If aborted, it'll cause a client side hard reload)
      // But let it to invalidate just after the completion.
      // So, it can re-build the queued pages at once.
      if (this.building) {
        this.rebuildAgain = true;
        return;
      }

      this.building = true;
      this.devMiddleware.invalidate();
    }
  }, {
<<<<<<< HEAD
    key: "startBuilding",
=======
    key: 'startBuilding',
>>>>>>> 3e7cc9eba236ff5c5205c34bae31be88b995768b
    value: function startBuilding() {
      this.building = true;
    }
  }, {
<<<<<<< HEAD
    key: "doneBuilding",
    value: function doneBuilding() {
      this.building = false;

=======
    key: 'doneBuilding',
    value: function doneBuilding() {
      this.building = false;
>>>>>>> 3e7cc9eba236ff5c5205c34bae31be88b995768b
      if (this.rebuildAgain) {
        this.rebuildAgain = false;
        this.invalidate();
      }
    }
  }]);
  return Invalidator;
}();