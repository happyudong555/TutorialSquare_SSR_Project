// @flow weak
<<<<<<< HEAD
/* eslint-disable no-param-reassign */

function isInside(scope, regex) {
  if (!scope.hub.file.opts) {
    return true
  }

  const filename = scope.hub.file.opts.filename

  if (!filename) {
    return true
  }

  return filename.match(regex) !== null
=======

function isInside(scope, regex) {
  if (!scope.hub.file.opts) {
    return true;
  }

  const filename = scope.hub.file.opts.filename;

  if (!filename) {
    return true;
  }

  return filename.match(regex) !== null;
>>>>>>> 3e7cc9eba236ff5c5205c34bae31be88b995768b
}

// Remove a specific path.
export default function remove(path, globalOptions, options) {
  const {
    visitedKey,
    unsafeWrapTemplate,
    wrapTemplate,
    mode,
    ignoreFilenames,
    types,
<<<<<<< HEAD
  } = globalOptions

  if (ignoreFilenames && isInside(path.scope, ignoreFilenames)) {
    return
=======
  } = globalOptions;

  if (ignoreFilenames && isInside(path.scope, ignoreFilenames)) {
    return;
>>>>>>> 3e7cc9eba236ff5c5205c34bae31be88b995768b
  }

  // Prevent infinity loop.
  if (path.node[visitedKey]) {
<<<<<<< HEAD
    return
  }

  path.node[visitedKey] = true
=======
    return;
  }

  path.node[visitedKey] = true;
>>>>>>> 3e7cc9eba236ff5c5205c34bae31be88b995768b

  if (mode === 'remove') {
    // remove() crash in some conditions.
    if (path.parentPath.type === 'ConditionalExpression') {
<<<<<<< HEAD
      path.replaceWith(types.unaryExpression('void', types.numericLiteral(0)))
    } else {
      path.remove()
    }

    return
=======
      path.replaceWith(types.unaryExpression('void', types.numericLiteral(0)));
    } else {
      path.remove();
    }

    return;
>>>>>>> 3e7cc9eba236ff5c5205c34bae31be88b995768b
  }

  if (mode === 'wrap' || mode === 'unsafe-wrap') {
    switch (options.type) {
      // This is legacy, we do not optimize it.
      case 'createClass':
<<<<<<< HEAD
        break

      // Inspired from babel-plugin-transform-class-properties.
      case 'class static': {
        let ref
        let pathClassDeclaration = options.pathClassDeclaration

        if (!pathClassDeclaration.isClassExpression() && pathClassDeclaration.node.id) {
          ref = pathClassDeclaration.node.id
        } else {
          // Class without name not supported
          return
        }

        const node = types.expressionStatement(
          types.assignmentExpression(
            '=',
            types.memberExpression(ref, path.node.key),
            path.node.value
          )
        )

        // We need to append the node at the parent level in this case.
        if (pathClassDeclaration.parentPath.isExportDeclaration()) {
          pathClassDeclaration = pathClassDeclaration.parentPath
        }
        pathClassDeclaration.insertAfter(node)
        path.remove()
        break
=======
        break;

      // Inspired from babel-plugin-transform-class-properties.
      case 'class static': {
        let ref;
        let pathClassDeclaration = options.pathClassDeclaration;

        if (!pathClassDeclaration.isClassExpression() && pathClassDeclaration.node.id) {
          ref = pathClassDeclaration.node.id;
        } else {
          // Class without name not supported
          return;
        }

        const node = types.expressionStatement(
          types.assignmentExpression('=', types.memberExpression(ref, path.node.key), path.node.value),
        );

        // We need to append the node at the parent level in this case.
        if (pathClassDeclaration.parentPath.isExportDeclaration()) {
          pathClassDeclaration = pathClassDeclaration.parentPath;
        }
        pathClassDeclaration.insertAfter(node);
        path.remove();
        break;
>>>>>>> 3e7cc9eba236ff5c5205c34bae31be88b995768b
      }

      case 'assign':
        if (mode === 'unsafe-wrap') {
<<<<<<< HEAD
          path.replaceWith(
            unsafeWrapTemplate({
              NODE: path.node,
            })
          )
        } else {
          path.replaceWith(
            wrapTemplate({
              LEFT: path.node.left,
              RIGHT: path.node.right,
            })
          )
        }
        path.node[visitedKey] = true
        break

      default:
        break
    }

    return
  }

  throw new Error(`transform-react-remove-prop-type: unsupported mode ${mode}.`)
=======
          path.replaceWith(unsafeWrapTemplate(
            {
              NODE: path.node,
            },
          ));
        } else {
          path.replaceWith(wrapTemplate(
            {
              LEFT: path.node.left,
              RIGHT: path.node.right,
            },
          ));
        }
        path.node[visitedKey] = true;
        break;

      default:
        break;
    }

    return;
  }

  throw new Error(`transform-react-remove-prop-type: unsupported mode ${mode}.`);
>>>>>>> 3e7cc9eba236ff5c5205c34bae31be88b995768b
}
